% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/select.R
\name{ts_tree_select}
\alias{ts_tree_select}
\alias{select2}
\title{Select elements in a tsjsonc object}
\arguments{
\item{x, json}{tsjsonc object.}

\item{i, ...}{Selectors, see below.}

\item{json}{tsjsonc object.}

\item{query}{String, a tree-sitter query.}
}
\value{
A tsjsonc object, potentially with some elements selected.
}
\description{
See https://tree-sitter.github.io/tree-sitter/ on writing tree-sitter
queries. Captured nodes of the TOML document will be selected.
}
\details{
This function is the heart of tsjsonc. To delete or manipulate parts of
a JSON document, you need to \code{\link[=ts_tree_select]{ts_tree_select()}} those parts first. To
insert new elements into a JSON document, you need to select the arrays
or objects the elements will be inserted into.
\subsection{Selectors}{

You can use a list of selectors to iteratively refine the selection
of JSON elements, starting from the document element (the default
selection).

For \code{\link[=ts_tree_select]{ts_tree_select()}} the list of selectors may be specified in a
single list argument, or as multiple arguments.

Available selectors:
\itemize{
\item \code{TRUE} selects all child elements of the current selections.
\item A character vector selects the named child elements from selected
objects. Selects nothing from arrays.
\item A numeric vector selectes the listed child elements from selected
arrays or objects. Positive (1-based) indices are counted from the
beginning, negative indices are counted from the end of the array or
object. E.g. -1 is the last element (if any).
\item A character scalar named \code{"regex"}, with a regular expression.
It selects the child elements whose keys match the regular expression.
Selects nothing from arrays.
}
}

\subsection{Refining selections}{

If the \code{refine} argument of \code{\link[=ts_tree_select]{ts_tree_select()}} is \code{TRUE}, then
the selection starts from the already selected elements (all of them
simultanously), instead of starting from the document element.
}

\subsection{The \code{[[} and \verb{[[<-} operators}{

The \code{[[} operator works similarly to [ts_tree_select())] on tsjsonc
objects, but it might be more readable.

The \verb{[[<-} operator works similarly to [ts_tree_select<-()], but it
might be more readable.

[ts_tree_select())]: R:ts_tree_select())
[ts_tree_select<-()]: R:ts_tree_select\%3C-()
}
}
\section{The JSON grammar}{


The grammar has the following node types. I included some less important
nodes in the subsection of other nodes that they are related to.

Comments may appear between any tokens, but they are not part of the
grammar.

Use the \link[ts:ts_tree-brackets]{bracket operator},
\code{\link[ts:ts_tree_dom]{ts::ts_tree_dom()}} and \code{\link[ts:ts_tree_ast]{ts::ts_tree_ast()}} to explore the parse tree
of a JSON document.
\subsection{\code{document}}{

#' A document is a single value.
}

\subsection{Values}{

A value is one of:
\itemize{
\item \code{object},
\item \code{array},
\item \code{numebr},
\item \code{string},
\item \code{true},
\item \code{false},
\item \code{null}.
}
}

\subsection{\code{object} / \code{pair}}{

An \code{object} is a sequence of
\itemize{
\item \verb{\{},
\item zero or more \code{pair} nodes, separated by \verb{,} nodes, trailing commas
are allowed,
\item \verb{\}}.
}

A pair is a series of
\itemize{
\item a key, a \code{string} node,
\item \code{:},
\item a value (see above).
}
}

\subsection{\code{array}}{

An \code{array} is a sequence of
\itemize{
\item \code{[},
\item zero or more values (see above), separated by \verb{,} nodes, trailing
commas are allowed,
\item \verb{]}.
}
}

\subsection{\code{number}}{

An integer or floating point number. Minus sign is part of the number.
Scientific notation is supported.
}

\subsection{\code{string} / \code{string_content} / \code{escape_sequence}}{

A string is a sequence of
\itemize{
\item a starting double quote (\verb{"}),
\item zero or more \code{string_content} or \code{escape_sequence} nodes,
\item an ending double quote (\verb{"}).
}
}

\subsection{\code{true} / \code{false} / \code{null}}{

The literals \code{true}, \code{false}, and \code{null}.

[`,
\itemize{
\item zero or more values (see above), separated by \verb{,} nodes, trailing
commas are allowed,
\item `]: R:\%60,\%0A-\%20zero\%20or\%20more\%20values\%20(see\%20above),\%20separated\%20by\%20\%60,\%60\%20nodes,\%20trailing\%0A\%20\%20commas\%20are\%20allowed,\%0A-\%20\%60
}
}
}

\examples{
json <- ts_parse_jsonc(ts_serialize_jsonc(list(
  a = list(a1 = list(1,2,3), a2 = "string"),
  b = list(4, 5, 6),
  c = list(c1 = list("a", "b"))
)))

json

# Select object by key
json |> ts_tree_select("a")

# Select within select, these are the same
json |> ts_tree_select("a", "a1")
json |> ts_tree_select(list("a", "a1"))

# Select elements of an array
json |> ts_tree_select("b", TRUE)           # all elements
json |> ts_tree_select("b", 1:2)            # first two elements
json |> ts_tree_select("b", c(1, -1))       # first and last elements

# Regular expressions
json |> ts_tree_select(c("a", "c"), c(regex = "1$"))
# A very simple JSON document
txt <- "{ \"a\": 1, \"b\": \"foo\", \"c\": 20 }"

# Take a look at it
ts_parse_jsonc(txt) |> ts_tree_format()

# Select all pairs where the value is a number and change them to 100
ts_parse_jsonc(txt) |>
  ts_tree_select_query("((pair value: (number) @num))") |>
  ts_tree_update(100)
}
